# simple-rpc
A simple rpc framework.

## 原理
往简单了说，这是一个外包的故事。

1. client -> 调用本地的服务类，期望得到服务的值；
1. 本地服务啥都不会干，那咋办嘛，外包出去，自己做代理工作，职业代理人；
1. 将任务交给外包人员server。任务的组成：协议名、方法名、参数等；
1. 外包搞定，结果交给代理；
1. 本地服务（也就是代理）将结果交给client。

本质上，流程就是这样。


但是涉及到细节的时候，流程就复杂了：

### 怎么联系外包公司？
最简单的办法，代理公司自己有个小本本，记录着外包公司的联系方式。需要外包任务的时候，就根据联系方式找他们。
显然，有一天外包公司换号码了，代理公司凉凉。

所以科学一些的方式，外包公司和代理公司约好，把联系方式放在某个地方，当代理公司需要联系的时候，去那个地方获取联系方式。
这样即使外包公司换号码了，代理公司去那个地方也能找到新的联系方式。

在实现上，就是用zookeeper充当一个**服务注册中心**。rpc服务器将自己的地址注册上去，客户端从
那里获取。同时zookeeper可以做到变动通知，一旦服务注册内容变了，可以通知client变动，更方便。

### 怎么把任务给外包公司？
外包公司，也就是rpc服务提供者，一般和client不在一台电脑上，怎么把任务给它发过去？tcp协议！
既然如此，发送的数据得是二进制，就得有**序列化和反序列**化。

在实现上，可以用一些现有的**序列化框架**，protobuf，avro，thrift之类的，具体选择要考虑序列化时间、
序列化后空间占用、可扩展性（协议字段拓展）等等。

### 傻等？
试想，代理公司的一个代理将任务交给外包，最简单的方式就是这个代理人员死等，等到外包完成之后将结果发过来，然后再返回给上层。
但是这样代理未免太傻了：
这是一种阻塞的请求方式，代理（一个线程）等结果的时候做不了什么，却又不直接交出时间片，只能空耗CPU资源。

更科学一些的，可以做到将任务交给外包，然后自己干其他事情去了，外包做好了通知代理一声，代理再接收结果。
这个就是**非阻塞**的请求方式。

要做成非阻塞的，实现上就复杂很多。

#### 哪个结果对应哪个任务？
首先，代理不再一次将一个任务从头盯到尾了。如果代理公司的很多代理人员同时外包出去多个任务，那么哪个结果对应哪个任务？毕竟不能说最先外包出去的一定是最先做完返回的。

所以需要一个**标记（request id）**，在任务返回的时候也要把这个标记带上，标志着这个结果属于具体哪一个任务。

实现上，可以用AtomicLong生成id。（为什么不生成一个uuid？大概是太长了吧，浪费网络资源）

#### 任务完成怎么做到异步通知？
代理发送任务之后，自己一边睡着去了，然后等外包公司通知自己之后，再醒来收结果。

怎么做到唤醒机制？外包公司怎么在代理人员甲的任务完成之后通知甲来处理结果？
实际上这里代理公司也应该有一些接线员（**用于接收消息的监听线程**），接收外包公司的结果。
收到结果之后，唤醒相应的代理人员去处理结果。

实现上可以使用**wait-notify**机制：
- client的一个线程（一个代理人员）发送任务，然后将request id和callback对象的对应关系存起来，比如ConcurrentHashMap；
- 该线程调用callback对象的get方法，方法内部，判断是否有结果，有则返回，没有则**wait**：
```java
public Object get() {
    // 获取该callback对象的锁
    synchronized(this) {
        // 使用while而非if判断是否完成（如果被恶意唤醒，实际还没完成，使用if就凉了）
        while(!isDone) {
            // 释放CPU，释放锁，阻塞线程，等待被唤醒
            wait();
        }
        // 被唤醒后，返回结果
        return result;
    }
}
```
- client监听线程接收到结果之后，反序列化，根据request id，从ConcurrentHashMap中找到对应的callback对象；
- 设置结果到callback对象里，然后唤醒阻塞的线程：
```java
private void doneJob(Object response) {
    // 获取该callback对象的锁
    synchronized(this) {
        // 设置结果
        this.result = response;
        // 设置完成标志
        this.isDone = true;
        // 唤醒阻塞的线程
        notifyAll();
    }
}
```
- 线程被唤醒，就可以获取到结果，继续处理了。

### 优化代理人员？
如果一个服务的内容是计算，里面有加减乘除四种具体服务，那么一个代理必须得知道有这四种服务，
并且client每次调用一种服务，代理人员就要将相应的服务外包出去。

简单能想到的弊端大概有两个：
- 如果服务新增了“取模运算”，那么这个代理计算服务的代理人员也得知道有这个服务，要不然client调用取模的时候，代理就傻了；
- 如果需要改规定，对中国的client调用的1+1输出“二”，美国client调用输出“Two”，其他情况输出“2”，那每一个代理的方法都要加上相应的内容。

两种情况都要去培训代理（增加新的代理服务、修改代理的结果返回）。尤其是后者，培训成本（改动代理类代码）太大了。

能不能有更简单的办法？

其实一开始我们说的代理，就是**静态代理**，实现简单，但是修改、拓展比较困难。

Java支持**动态代理**，所谓动态，就是不要提前写死一个Java类能做的功能（静态代理），而是
动态地生成一个代理对象，该对象在调用某个服务时，按照InvocationHandler#invoke的逻辑依次执行代理行为。

## 总结
要实现一个还不错的rpc框架，大致这些技术都是需要的。但是这些只是为了让一个rpc框架变得丰富，实用，
实际上即便去掉这些，依然是一个rpc框架，只不过用起来体验不好而已。

最简易的rpc的思路，还是挺好理解的。

